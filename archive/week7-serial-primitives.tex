\documentclass{article}
\usepackage{fontspec}
\setmainfont{Lucida Bright}
\setmonofont{Lucida Sans Typewriter}

\usepackage{listings}
\lstset{
	language=Java,
	basicstyle=\footnotesize\ttfamily,
}  

\begin{document}

\section{Week 7: Ruby serial primitives}

This part of work is about how to compile Ruby serial primitives to MaxJ code, mainly \texttt{pdsr} and \texttt{sdpr}. 

\subsection{\texttt{showGate} and Function Device}
\texttt{showGate} is the core function to generate the MaxJ expression of a Ruby circuit. For instance, \texttt{add} primitive will be transformed to "+" by using \texttt{showGate}. But things will be different for \texttt{pdsr} and \texttt{sdpr}, as \texttt{showGate} currently could only support infix, eq and some other basic primitives, there's nothing like "function" has been supported, which will be quite useful to definie \texttt{pdsr} and \texttt{sdpr}.

Briefly, my approach is:
\begin{enumerate}
\item Add a condition filter \texttt{isFunc} in \texttt{showGate}, to check whether the current device is a \textbf{function device}, which should be implemented like \texttt{func(t1, t2)} in MaxJ. 
\item Append the builtin function definition backward in the kernel class definition. 
\end{enumerate}

\subsection{\texttt{pdsr} and \texttt{sdpr}}
How to define these 2 primitives in MaxJ? The simplest way is using a combination of \textbf{counter} and \textbf{mutiplexer}, which should be \texttt{simpleCounter} and \texttt{mux} in MaxJ. A simple definition for \texttt{pdsr 2} is:

\begin{lstlisting}
private DFEVar pdsr2(DFEVar t0,DFEVar t1) {
  DFEVar counter = control.count.simpleCounter(
    			MathUtils.bitsToAddress(2));
  return control.mux(counter, t0, t1);
}
\end{lstlisting}

This snippet of code is auto-generated, and suit for different value of n in \texttt{pdsr n} expression.

\end{document}