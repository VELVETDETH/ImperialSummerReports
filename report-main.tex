\documentclass[a4paper, 10pt]{article}

\usepackage{fontspec}
\setmainfont{Lucida Bright}
\setmonofont{Lucida Sans Typewriter}

\usepackage{listings}
\lstset{
	language=Java,
	basicstyle=\footnotesize\ttfamily,
}  
\usepackage{amsmath}

\begin{document}

\title{Summer Research Reports}
\author{Vincent Zhao\\
		\texttt{vincentzhaorz@gmail.com}}
\maketitle

\begin{abstract}
This is the 7th week of my summer research, and this report will contain mainly what I've done in the past 2 weeks, including MaxJ SpMV inplementation, Ruby multipumping implementation, and some bug fix in Ruby compiler.
\end{abstract}
\newpage

\tableofcontents

\newpage


\section{Week7: BCSR and Multi-pumped Implementation}

\subsection{What is BCSR?}
BCSR is a sparse matrix format which is based on well-known CSR format. It's basic element is little block of non-zeros, just like cutting CSR to little blocks. Each block has a shape of $r \times c$, where r and c's value will not be so large. 

The BCSR format contains 2 main procedures, one is converting, which will transform a traditional COO format to BCSR format storage. The other one is computing, which will do computation on BCSR format.

\subsubsection{Convert}
The convert procedure will act like this, for example here's a sparse matrix A:
\[
A = 
\begin{bmatrix}
	a & 0 & b & c \\
	d & e & f & 0 \\
	0 & 0 & 0 & g \\
	0 & h & i & 0
\end{bmatrix}
\]

If it's a CSR format, the final result would be:
\[
A_{csr} = 
\begin{bmatrix}
	a & b & c \\
	d & e & f \\
	g \\
	h & i
\end{bmatrix}
\]

And for a BCSR format, the result would be:
\[
A_{bcsr} =
\begin{bmatrix}
	a & b\\
	d & e
\end{bmatrix}
,
\begin{bmatrix}
	c & 0\\
	f & 0
\end{bmatrix}
,
\begin{bmatrix}
	g & 0\\
	h & i
\end{bmatrix}
\]

\subsubsection{Compute}


\subsection{Why choose BCSR on FPGA?}

\subsection{BCSR Implementation}

\subsection{BCSR Performance}

Let's check out the maximal performance we could get if this design is IO-bound. If the PCIe bandwidth is 2GB/s, and we'll input 2 32-bits data, one for index, the other one for value, for each non zero. So we could process data per second:
$$ \text{Non zero per second} = \frac{2(GB/s)}{2\times4(Byte)} = 0.25(G/s) $$

And for each non zero, we will have 2 floating point operations(adder and multiplier), so the maximal GFlops we could get is:
$$ \text{GFlops} = 0.25 (G/s) \times 2(Flop) = 0.5 $$

\subsection{Multi-pumped BCSR design}

Referring to the BCSR format, we will calculate multiple multiplication in one single tick, which is a brillliant feature to be multi-pumped. But due to the constraints of MaxCompiler, we need to have multiple kernel blocks now, as we could only assign one universal clock rate to each kernel. We could divide this multi-pumped BCSR design into 3 parts:

\begin{description}
\item[Gather] For each pipe, we need to gather the input vector and value vector. Input vector means the values in the vector parameter, read from ROM. 
\item[Multiply] We send those input and value vectors to this multiply part, and this part runs at 2x clock rate, which is the computation core of multi-pumping design.
\item[Sum] Will take result from multi-pumping multipliers and use summation tree to sum them up. It will also take a \texttt{start} stream to denote whether the current calculated block is the start of each group.
\end{description}

\input{archive/week7-serial-primitives}

\newpage

\section{Reports Archive}
\input{archive/week3-report.tex} \newpage
\input{archive/week4-report.tex} \newpage
\input{archive/week5n6-report.tex} \newpage
   
\end{document}
