\documentclass[a4paper, 10pt]{article}

\usepackage{fontspec}
\setmainfont{Lucida Bright}
\setmonofont{Lucida Sans Typewriter}

\usepackage{listings}
\lstset{
	language=Java,
	basicstyle=\footnotesize\ttfamily,
}  

\begin{document}

\title{Summer Research Reports}
\author{Vincent Zhao\\
		\texttt{vincentzhaorz@gmail.com}}
\maketitle

\begin{abstract}
This is the 7th week of my summer research, and this report will contain mainly what I've done in the past 2 weeks, including MaxJ SpMV inplementation, Ruby multipumping implementation, and some bug fix in Ruby compiler.
\end{abstract}
\newpage

\tableofcontents

\newpage

\section{MaxJ SpMV Implementation}

Compressed Sparse Row(CSR) is a famous sparse matrix storage method, it pull all the non zeros to the left of their own row, and store their original column index before they have been aligned. I'm building my SpMV algorithm based on this format. 

\subsection{CSRP format introduction}
In order to reduce complex control logic which could slow down the processing and introduce bugs, there'll be \textbf{padding} zeros at the end of each row, in order to make those rows, which will be processed together, have the same number of elements to calculate(although there'll be some useless zeros). That's the idea about CSRP format.

\subsubsection{Redundancy formalization}

If we align all our rows to the row with maximal number of nonzeros, then we could imagine there'll be lots of redundancy. As we will process only a small number of rows at the same time(number of pipes), we could just align rows to the longest row in each \textbf{processing group}.

Let's formalize this description: If we have N rows for one sparse matrix, and for row $i$ it has $L_i$ number of non zeros. And if we group all these rows by $R$, which is the number of pipes for our design, then all these $R$ rows in one group will be calculated together. So we could devise this formula:

The lower bound of our \textbf{redundant} calculation cycles will be:
\begin{equation}
Redundant\ cycles = \sum_{i}^{N/R} R \times \max_{j}^{R} L_{i\times R + j} - \sum_{i}^{N} L_i
\end{equation}

\subsubsection{Redundancy Optimization}

If we transform formula (1) to this form:

\begin{equation}
Redundant\ cycles = \sum_{i}^{N/R} (R \times \max_{j}^{R} L_{i\times R + j} - \sum_{j}^{R} L_{i \times R + j})
\end{equation}

So here's a heuristic rule: we need to make sure there's no such case, that a very long row and several short rows coexist in one group. According to this idea, we could simply do a \textbf{sorting} on the rows by their length(which is a greedy algorithm). Is this really the best solution? We could easily prove it. 

Imagine that we have $N/R$ "buckets", each bucket could contain $R$ rows. And now we need to put rows inside those buckets. We suppose that the best solution is put rows one by one in the sorted sequence, which means that the rows in the first group will be the rows with top $R$ number of non zeros.

If there's a better solution than this one, then it should have swapped some of its elements. If we swap 2 rows between 2 groups, then it will increase redundancy in both groups.

\subsection{Performance}

I've tested this format with different $R$ value, and 2 extreme sparse matrix format: dense and triagle. The following features have been discovered:
\begin{enumerate}
\item The maximal performance I could get is by using design with $R$ equals to 32, and for dense matrix, GFlops is 0.28, for triangle matrix, it's 0.22.
\item With larger $R$ value, the performance increase at first, and the fall down.
\item If $R$ is larger, then redundancy will be larger.
\end{enumerate}

More detailed test and report will be attached once I've finished the final version.

\subsection{Week7: BCSR and Multi-pumped Implementation}

\subsubsection{BCSR Description}

\subsubsection{BCSR Performance}

\subsubsection{Multi-pumped BCSR design}

Referring to the BCSR format, we will calculate multiple multiplication in one single tick, which is a brillliant feature to be multi-pumped. But due to the constraints of MaxCompiler, we need to have multiple kernel blocks now, as we could only assign one universal clock rate to each kernel. We could divide this multi-pumped BCSR design into 3 parts:

\begin{description}
\item[Gather] For each pipe, we need to gather the input vector and value vector. Input vector means the values in the vector parameter, read from ROM. 
\item[Multiply] We send those input and value vectors to this multiply part, and this part runs at 2x clock rate, which is the computation core of multi-pumping design.
\item[Sum] Will take result from multi-pumping multipliers and use summation tree to sum them up. It will also take a \texttt{start} stream to denote whether the current calculated block is the start of each group.
\end{description}

\section{Ruby Multi-Pumping Implementation}

\subsection{Ruby serialization primitives}

\subsection{Different aspects and implementations}

\section{Ruby cyclic loop}

\subsection{Problem: MaxCompiler auto-pipelining}

\subsection{Solution}

\section{Week 7: Ruby serial primitives}

This part of work is about how to compile Ruby serial primitives to MaxJ code, mainly \texttt{pdsr} and \texttt{sdpr}. 

\subsection{\texttt{showGate} and Function Device}
\texttt{showGate} is the core function to generate the MaxJ expression of a Ruby circuit. For instance, \texttt{add} primitive will be transformed to "+" by using \texttt{showGate}. But things will be different for \texttt{pdsr} and \texttt{sdpr}, as \texttt{showGate} currently could only support infix, eq and some other basic primitives, there's nothing like "function" has been supported, which will be quite useful to definie \texttt{pdsr} and \texttt{sdpr}.

Briefly, my approach is:
\begin{enumerate}
\item Add a condition filter \texttt{isFunc} in \texttt{showGate}, to check whether the current device is a \textbf{function device}, which should be implemented like \texttt{func(t1, t2)} in MaxJ. 
\item Append the builtin function definition backward in the kernel class definition. 
\end{enumerate}

\subsection{\texttt{pdsr} and \texttt{sdpr}}
How to define these 2 primitives in MaxJ? The simplest way is using a combination of \textbf{counter} and \textbf{mutiplexer}, which should be \texttt{simpleCounter} and \texttt{mux} in MaxJ. A simple definition for \texttt{pdsr 2} is:

\begin{lstlisting}
private DFEVar pdsr2(DFEVar t0,DFEVar t1) {
  DFEVar counter = control.count.simpleCounter(
    			MathUtils.bitsToAddress(2));
  return control.mux(counter, t0, t1);
}
\end{lstlisting}

This snippet of code is auto-generated, and suit for different value of n in \texttt{pdsr n} expression.

\newpage

\section{Reports Archive}
\input{archive/week3-report.tex} \newpage
\input{archive/week4-report.tex} \newpage
   
\end{document}
